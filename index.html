<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>Turbo Turf Trimmer</title>
  <style>
    :root { --bg:#0b1b0f; --ui: rgba(255,255,255,0.9); --accent:#2fe06f; }
    html,body{height:100%}
    body{margin:0;background:var(--bg);overflow:hidden;font-family:system-ui,-apple-system,Segoe UI,Roboto,Inter,Arial,sans-serif;color:#fff}
    #game{display:block;width:100vw;height:100vh;touch-action:none;z-index:0;position:relative}
    /* Glass HUD */
    .hud{
      position:fixed;inset:12px auto auto 12px;z-index:10;display:flex;gap:10px;align-items:center;flex-wrap:wrap;
      background:rgba(0,0,0,.35);backdrop-filter:blur(6px);
      border:1px solid rgba(255,255,255,.12);border-radius:14px;padding:8px 10px;
      box-shadow:0 8px 24px rgba(0,0,0,.35)
    }
    .pill{padding:6px 10px;border-radius:999px;background:rgba(255,255,255,.1);font-weight:700}
    .pill.time{min-width:14ch}
    .btn{-webkit-tap-highlight-color:transparent;touch-action:manipulation;user-select:none;-webkit-user-select:none;cursor:pointer;border:0;border-radius:10px;padding:8px 12px;font-weight:800;background:#111;color:#fff;outline:1px solid rgba(255,255,255,.16)}
    .btn:hover{outline-color:rgba(255,255,255,.36)}
    /* Compact HUD on small screens */
    @media (max-width: 480px) {
      .hud{inset:8px auto auto 8px;padding:6px 8px;gap:8px;border-radius:12px}
      .btn{padding:6px 10px;border-radius:8px;font-size:14px}
      .pill{padding:5px 8px;border-radius:999px;font-size:14px}
    }

    .help{position:fixed;right:16px;bottom:16px;z-index:10;max-width:420px;line-height:1.35;font-size:14px;color:rgba(255,255,255,.9);background:rgba(0,0,0,.35);backdrop-filter:blur(6px);border:1px solid rgba(255,255,255,.12);border-radius:12px;padding:12px 14px}
    .help kbd{background:#111;color:#fff;border-radius:6px;padding:2px 6px;border:1px solid rgba(255,255,255,.2)}
    .stick{position:fixed;left:16px;bottom:16px;width:120px;height:120px;z-index:9;border-radius:50%;background:rgba(0,0,0,.25);border:1px solid rgba(255,255,255,.12);touch-action:none}
    .stick .nub{position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);width:52px;height:52px;border-radius:50%;background:rgba(255,255,255,.6);mix-blend-mode:screen;box-shadow:0 8px 24px rgba(0,0,0,.35);pointer-events:none}
    /* Retro intro */
    .intro{position:fixed;inset:0;display:flex;flex-direction:column;align-items:center;justify-content:center;z-index:20;background:radial-gradient(1200px 800px at 50% 50%, rgba(15,40,20,.95), rgba(6,18,10,.98));text-align:center;pointer-events:auto}
    .title{font-family:"Courier New",monospace;font-weight:800;letter-spacing:2px;text-transform:uppercase;font-size:clamp(28px,6vw,72px);text-shadow:0 0 6px #1aff7a,0 0 18px #0aff52,2px 2px 0 #000;margin:0 0 10px 0}
    .subtitle{font-family:"Courier New",monospace;color:#bfffd6;opacity:.9;margin-bottom:10px}
    .credit{opacity:.7;font-size:12px;margin-top:16px;font-family:"Courier New",monospace}
    .modebar{display:flex;gap:8px;margin:12px 0 18px 0;flex-wrap:wrap;justify-content:center}
    .modebtn{background:#0f0f0f;outline:1px solid rgba(255,255,255,.2)}
    .modebtn.active{outline-color:#2fe06f; box-shadow:0 0 0 2px rgba(47,224,111,.25) inset}
    .sel{margin-top:6px;opacity:.85}
    /* Win / Fail modals */
    .modal{position:fixed;inset:0;display:none;align-items:center;justify-content:center;z-index:30;background:rgba(0,0,0,.55);backdrop-filter:blur(3px)}
    .modal.show{display:flex}
    .card{background:rgba(0,0,0,.6);border:1px solid rgba(255,255,255,.15);border-radius:14px;padding:18px;min-width:280px;text-align:center;box-shadow:0 12px 36px rgba(0,0,0,.45)}
    .card h2{margin:0 0 6px 0}
    .bestlist{list-style:none;margin:8px 0 0 0;padding:0;font-variant-numeric:tabular-nums;text-align:left}
    .bestlist li{display:flex;justify-content:space-between;padding:2px 0}
    /* Score sidebar */
    .sidebar{position:fixed;top:16px;right:16px;z-index:10;background:rgba(0,0,0,.35);backdrop-filter:blur(6px);border:1px solid rgba(255,255,255,.12);border-radius:12px;padding:10px 12px;min-width:220px}
    .sidebar h4{margin:0 0 6px 0;font-size:14px;opacity:.9}
    .time{font-variant-numeric:tabular-nums;font-weight:700}
    /* Mobile fix: bump help box up when joystick is present */
    .touch .help { bottom: 152px; }
    @media (max-width: 768px) {
      .sidebar { top: auto; bottom: 12px; right: 12px; left: auto; }
    }
    .touch .sidebar { top: auto; bottom: calc(152px + 8px); right: 16px; left: auto; }

    /* Prevent timer bounce */
    #time, #countdown {
      font-variant-numeric: tabular-nums;
      font-feature-settings: "tnum" 1;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
      display: inline-block;
      min-width: 8ch;
      text-align: left;
    }

    /* Smooth fade/slide for the help card + hidden state */
    .help{ transition: opacity .35s ease, transform .35s ease; }
    .help.hidden{ opacity:0; transform: translateY(8px); pointer-events:none; }

    /* Small '?' toggle button to re-open help */
    #helpToggle{
      position:fixed;
      right:16px;
      bottom:16px;
      z-index:32;
      border:1px solid rgba(255,255,255,.18);
      background:#0f0f0f;
      color:#fff;
      border-radius:999px;
      padding:6px 10px;
      font-weight:700;
      cursor:pointer;
      -webkit-tap-highlight-color:transparent;
      box-shadow:0 8px 24px rgba(0,0,0,.35);
    }
    .touch #helpToggle{ bottom:16px; right:16px; }
    /* Best Times toggle button */
    #bestToggle{
      position:fixed;
      right:16px;
      bottom:58px; /* stack above '?' */
      z-index:32;
      border:1px solid rgba(255,255,255,.18);
      background:#0f0f0f;
      color:#fff;
      border-radius:999px;
      padding:6px 10px;
      font-weight:700;
      cursor:pointer;
      -webkit-tap-highlight-color:transparent;
      box-shadow:0 8px 24px rgba(0,0,0,.35);
    }
    .touch #bestToggle{ right:16px; bottom:58px; }

    /* On mobile: hide sidebar by default; show only when .show is set */
    @media (max-width: 768px) {
      .sidebar{ display:none; }
      .sidebar.show{ display:block; }
    }
  </style>
</head>
<body>
  <canvas id="game"></canvas>
  <!-- MUSIC -->
  <audio id="bgm" src="retro.mp3" preload="auto" loop playsinline></audio>

  <div class="hud" id="hud">
    <div class="pill">Cut: <span id="pct">0</span>%</div>
    <div class="pill">Elapsed: <span id="time">00:00.0</span></div>
    <div class="pill">Countdown: <span id="countdown">--:--</span></div>
    <button class="btn" id="reset">Reset (R)</button>
    <button class="btn" id="fullscreen">Fullscreen (F)</button>
    <button class="btn" id="musicToggle">Music: On</button>
  </div>

  <div class="help">
    <strong>How to play:</strong> Arrow keys / WASD to drive. On touch, use the left joystick or drag.
    Press <kbd>Enter</kbd> or click <em>Start</em> to begin. Mow everything before time runs out!<br>
    Pro-tip: diagonal lines and tight spirals cut faster.
  </div>
  <button class="btn" id="helpToggle" aria-label="Toggle help">?</button>
  <button class="btn" id="bestToggle" aria-label="Toggle best times" title="Best Times">üèÅ</button>

  <div class="stick" id="stick" aria-hidden="true"><div class="nub" id="nub"></div></div>

  <!-- Intro overlay -->
  <div class="intro" id="intro">
    <h1 class="title">Turbo Turf Trimmer</h1>
    <div class="subtitle">1993 ‚Äî <span style="color:#2fe06f">Arcade Mode</span></div>

    <div class="modebar" id="modeBar">
      <button class="btn modebtn" data-mode="easy">Easy ¬∑ 5:00 ¬∑ Wide mower</button>
      <button class="btn modebtn" data-mode="normal">Normal ¬∑ 3:00</button>
      <button class="btn modebtn" data-mode="hard">Hard ¬∑ 1:30 ¬∑ Narrow mower</button>
    </div>
    <div class="sel" id="sel">Selected: Normal</div>

    <button class="btn" id="startBtn">‚ñ∂ Start</button>
    <div class="credit">Use WASD / Arrows ¬∑ Touch joystick on mobile</div>
  </div>

  <!-- Score sidebar -->
  <aside class="sidebar" id="sidebar">
    <h4>Best Times</h4>
    <ol class="bestlist" id="bestList"></ol>
  </aside>

  <!-- Win modal -->
  <div class="modal" id="winModal">
    <div class="card">
      <h2>Good job! üå±</h2>
      <div>All grass cut in <strong class="time" id="finalTime">00:00.0</strong></div>
      <div style="margin-top:10px; display:flex; gap:8px; justify-content:center;">
        <button class="btn" id="againBtn">Restart</button>
        <button class="btn" id="closeModalBtn">Close</button>
      </div>
      <div style="margin-top:10px; font-size:12px; opacity:0.8;">Your time is saved in Best Times</div>
    </div>
  </div>

  <!-- Fail modal -->
  <div class="modal" id="failModal">
    <div class="card">
      <h2>Time's up! ‚è∞</h2>
      <div>You cleared <strong id="finalPct">0%</strong> in time.</div>
      <div style="margin-top:10px; display:flex; gap:8px; justify-content:center;">
        <button class="btn" id="retryBtn">Try Again</button>
        <button class="btn" id="closeFailBtn">Close</button>
      </div>
    </div>
  </div>

<script>
(()=>{
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d', { alpha: false });
  const pctEl = document.getElementById('pct');
  const timeEl = document.getElementById('time');
  const cdEl = document.getElementById('countdown');
  const winModal = document.getElementById('winModal');
  const failModal = document.getElementById('failModal');
  const finalPctEl = document.getElementById('finalPct');
  const finalTimeEl = document.getElementById('finalTime');
  const bestListEl = document.getElementById('bestList');
  const intro = document.getElementById('intro');
  const startBtn = document.getElementById('startBtn');
  const againBtn = document.getElementById('againBtn');
  const retryBtn = document.getElementById('retryBtn');
  const closeModalBtn = document.getElementById('closeModalBtn');
  const closeFailBtn = document.getElementById('closeFailBtn');
  const bestToggle = document.getElementById('bestToggle');
  const modeBar = document.getElementById('modeBar');
  const sel = document.getElementById('sel');

  // MUSIC
  const bgm = document.getElementById('bgm');
  const musicToggle = document.getElementById('musicToggle');
  const MUSIC_KEY = 'mower_music_enabled_v1';
  let musicEnabled = localStorage.getItem(MUSIC_KEY) !== 'false'; // default On
  function setMusicUI(){ musicToggle.textContent = 'Music: ' + (musicEnabled ? 'On' : 'Off'); }
  setMusicUI();

  const dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));

  // Help auto-hide toggle only after start
  const help = document.querySelector('.help');
  const helpToggle = document.getElementById('helpToggle');
  function hideHelp(){ help?.classList.add('hidden'); }
  helpToggle?.addEventListener('click', ()=> help?.classList.toggle('hidden'));

  // Detect touch device and add class
  const isTouch = 'ontouchstart' in window || navigator.maxTouchPoints > 0;
  if (isTouch) document.body.classList.add('touch');

  // Field/grid
  let W=0, H=0, cols=0, rows=0, cell=8, total=0, cutCount=0;
  let cut; let shade; let cutAge; let blocked;
  let grassTotal=0;
  let house = {x:0,y:0,w:0,h:0};
  let SAFE_TOP = 0;

  const hud = document.getElementById('hud');
  function computeSafeTop(){
    const r = hud.getBoundingClientRect();
    SAFE_TOP = Math.ceil(r.bottom + 10);
  }

  // Game state
  let state = 'intro';
  let tStart = 0;
  let elapsed = 0;
  const BEST_KEY = 'mower_best_times_v1';
  const MODE_KEY = 'mower_last_mode';
  let mode = localStorage.getItem(MODE_KEY) || 'normal';

  // Mower
  const mower = { x:0, y:0, dir:0, speed:260, radius:24, vx:0, vy:0 };

  // Modes
  const MODES = {
    easy:   { timeMs: 5*60*1000, radius: 30, label:'Easy' },
    normal: { timeMs: 3*60*1000, radius: 24, label:'Normal' },
    hard:   { timeMs: 90*1000,   radius: 18, label:'Hard' }
  };
  let countdownMs = MODES[mode].timeMs;
  let remainingMs = countdownMs;

  // Input
  const keys = new Set();
  let pointerTarget = null;

  // Virtual stick
  const stick = document.getElementById('stick');
  const nub = document.getElementById('nub');
  let stickActive=false, stickVec={x:0,y:0};

  // Mode selection ‚Äî direct listeners on each button
  function setMode(m){
    if (!MODES[m]) return;
    mode = m;
    localStorage.setItem(MODE_KEY, mode);
    sel.textContent = 'Selected: ' + MODES[mode].label;
    modeBar.querySelectorAll('.modebtn').forEach(b=> b.classList.toggle('active', b.dataset.mode === mode));
  }
  // Attach listeners
  modeBar.querySelectorAll('.modebtn').forEach(btn=>{
    const handler = (e)=>{ e.preventDefault(); e.stopPropagation(); setMode(btn.dataset.mode); };
    btn.addEventListener('touchstart', handler, { passive:false });
    btn.addEventListener('pointerdown', handler);
    btn.addEventListener('click', handler);
  });
  // Initialize UI
  setMode(mode);

  function resize(reset=true){
    W = Math.floor(window.innerWidth);
    H = Math.floor(window.innerHeight);
    canvas.width = Math.floor(W * dpr);
    canvas.height = Math.floor(H * dpr);
    canvas.style.width = W + 'px';
    canvas.style.height = H + 'px';
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
    cols = Math.ceil(W / cell);
    rows = Math.ceil(H / cell);
    total = cols * rows;
    computeSafeTop();
    if (reset) initField();
  }
  function idx(cx,cy){ return cx + cy * cols; }

  function initField(){
    cutCount = 0;
    cut = new Uint8Array(total);
    shade = new Float32Array(total);
    cutAge = new Float32Array(total);
    blocked = new Uint8Array(total);

    // House near top-center
    house.w = Math.max(180, Math.floor(W*0.18));
    house.h = Math.max(120, Math.floor(H*0.16));
    house.x = Math.floor(W*0.5 - house.w/2);
    house.y = Math.max(Math.floor(H*0.12), SAFE_TOP + 10); // ensure below safe band

    for(let y=0;y<rows;y++){
      for(let x=0;x<cols;x++){
        const i=idx(x,y);
        const cx = x*cell + cell*0.5;
        const cy = y*cell + cell*0.5;
        shade[i] = Math.random();
        cutAge[i] = 0;
        // Block the HUD-safe band at the top
        if (cy < SAFE_TOP) { blocked[i] = 1; continue; }
        // Block house
        if (cx>house.x && cx<house.x+house.w && cy>house.y && cy<house.y+house.h) blocked[i]=1;
      }
    }
    grassTotal = 0; for(let i=0;i<total;i++) if(!blocked[i]) grassTotal++;

    mower.x=W*0.5;
    mower.y=Math.max(house.y+house.h+60, SAFE_TOP + 120);
    mower.vx=0; mower.vy=0; mower.dir=0;

    mower.radius = MODES[mode].radius;
    countdownMs = MODES[mode].timeMs;
    remainingMs = countdownMs;
    cdEl.textContent = fmtCountdown(remainingMs);

    updatePercent(); updateTime(0);
  }

  function updatePercent(){
    const pct = grassTotal ? Math.round((cutCount/grassTotal)*100) : 0;
    pctEl.textContent = String(pct);
  }
  function updateTime(ms){
    const s = ms/1000; const m = Math.floor(s/60); const sec = Math.floor(s%60); const d = Math.floor((s - Math.floor(s)) * 10);
    timeEl.textContent = `${String(m).padStart(2,'0')}:${String(sec).padStart(2,'0')}.${d}`;
  }
  function fmtCountdown(ms){
    const s = Math.max(0, Math.ceil(ms/1000));
    const m = Math.floor(s/60);
    const sec = s % 60;
    return `${String(m).padStart(2,'0')}:${String(sec).padStart(2,'0')}`;
  }
  function handleCut(cx,cy){
    if (cx<0||cy<0||cx>=cols||cy>=rows) return;
    const i = idx(cx,cy);
    if (blocked[i]) return;
    if (!cut[i]){ cut[i]=1; cutCount++; cutAge[i]=1; if (cutCount===grassTotal) onAllCut(); }
  }
  function cutUnderMower(){
    const r=mower.radius; const r2=r*r;
    const minx=Math.max(0, Math.floor((mower.x-r)/cell));
    const maxx=Math.min(cols-1, Math.floor((mower.x+r)/cell));
    const miny=Math.max(0, Math.floor((mower.y-r)/cell));
    const maxy=Math.min(rows-1, Math.floor((mower.y+r)/cell));
    for(let y=miny;y<=maxy;y++){
      for(let x=minx;x<=maxx;x++){
        const cx=x*cell+cell*0.5, cy=y*cell+cell*0.5;
        const dx=cx-mower.x, dy=cy-mower.y;
        if (dx*dx+dy*dy<=r2) handleCut(x,y);
      }
    }
  }

  function uncutColorHC(s){ const g = 110 + Math.floor(s*40); return `rgb(${12+Math.floor(s*8)},${g},${22+Math.floor(s*12)})`; }
  function cutColorHC(s){ const g = 200 + Math.floor(s*25); return `rgb(${160+Math.floor(s*10)},${g},${160+Math.floor(s*10)})`; }

  function drawField(){
    for(let y=0;y<rows;y++){
      for(let x=0;x<cols;x++){
        const i=idx(x,y), s=shade[i];
        const X = x*cell, Y = y*cell;
        if (blocked[i]){
          ctx.fillStyle = uncutColorHC(s);
          ctx.fillRect(X, Y, cell, cell);
          if ((x % 3) === 0) { ctx.fillStyle='rgba(0,0,0,0.08)'; ctx.fillRect(X+cell-1, Y, 1, cell); }
          continue;
        }
        if (!cut[i]){
          ctx.fillStyle = uncutColorHC(s);
          ctx.fillRect(X, Y, cell, cell);
          if ((x % 3) === 0) { ctx.fillStyle='rgba(0,0,0,0.08)'; ctx.fillRect(X+cell-1, Y, 1, cell); }
        } else {
          ctx.fillStyle = cutColorHC(s);
          ctx.fillRect(X, Y, cell, cell);
          if ((y & 1) === 0) { ctx.fillStyle='rgba(0,0,0,0.10)'; ctx.fillRect(X, Y+cell-2, cell, 1); }
          if (cutAge[i] > 0){
            ctx.strokeStyle = `rgba(255,255,120,${Math.min(1, cutAge[i])})`;
            ctx.lineWidth = 1;
            ctx.strokeRect(X+0.5, Y+0.5, cell-1, cell-1);
            cutAge[i] = Math.max(0, cutAge[i]-0.04);
          }
        }
      }
    }
  }

  function drawFence(){
    const y = SAFE_TOP;
    ctx.fillStyle = '#7a4a2a';
    ctx.fillRect(0, y-6, W, 4);
    ctx.fillRect(0, y+2, W, 4);
    for (let x=0; x<=W; x+=56){
      ctx.fillStyle = '#8a5a32';
      ctx.fillRect(x-3, y-10, 6, 22);
      ctx.fillStyle = 'rgba(255,255,255,0.15)';
      ctx.fillRect(x-3, y-10, 6, 2);
    }
    const grad = ctx.createLinearGradient(0, y, 0, y+20);
    grad.addColorStop(0, 'rgba(0,0,0,0.25)');
    grad.addColorStop(1, 'rgba(0,0,0,0)');
    ctx.fillStyle = grad;
    ctx.fillRect(0, y, W, 20);
  }

  function drawHouse(){
    ctx.fillStyle = '#cfc1a1';
    ctx.fillRect(house.x, house.y, house.w, house.h);
    ctx.beginPath();
    ctx.moveTo(house.x-8, house.y);
    ctx.lineTo(house.x + house.w/2, house.y - Math.min(80, house.h*0.6));
    ctx.lineTo(house.x + house.w+8, house.y);
    ctx.closePath();
    ctx.fillStyle = '#7a3b1d'; ctx.fill();
    const doorW=Math.max(24, Math.floor(house.w*0.14)), doorH=Math.max(44, Math.floor(house.h*0.5));
    const doorX=house.x + Math.floor(house.w*0.5) - doorW/2, doorY=house.y + house.h - doorH;
    ctx.fillStyle='#56351e'; ctx.fillRect(doorX,doorY,doorW,doorH);
    ctx.fillStyle='#9ed9ff';
    const pad=Math.floor(house.w*0.08), winW=Math.max(22,Math.floor(house.w*0.2)), winH=Math.max(18,Math.floor(house.h*0.24));
    ctx.fillRect(house.x+pad, house.y+pad, winW, winH);
    ctx.fillRect(house.x+house.w-pad-winW, house.y+pad, winW, winH);
  }

  function drawGuy(){
    const back = 22;
    const px = mower.x - Math.cos(mower.dir||0)*back;
    const py = mower.y - Math.sin(mower.dir||0)*back;
    ctx.save(); ctx.translate(px, py); ctx.rotate(mower.dir||0);
    ctx.strokeStyle = 'rgba(200,200,200,0.9)'; ctx.lineWidth=2; ctx.beginPath(); ctx.moveTo(0,-8); ctx.lineTo(back,-6); ctx.stroke();
    ctx.fillStyle = '#3aa7ff'; ctx.fillRect(-6,-14,12,18);
    ctx.fillStyle = '#222'; ctx.fillRect(-6,4,5,10); ctx.fillRect(1,4,5,10);
    ctx.fillStyle = '#f5d7b1'; ctx.beginPath(); ctx.arc(0,-20,6,0,Math.PI*2); ctx.fill();
    ctx.restore();
  }

  function drawMower(){
    const w=44,h=28; ctx.save(); ctx.translate(mower.x,mower.y);
    const ang=Math.atan2(mower.vy,mower.vx); if(mower.vx||mower.vy) mower.dir=ang; ctx.rotate(mower.dir);
    ctx.fillStyle='rgba(255,255,255,0.08)'; ctx.beginPath(); ctx.arc(0,0,mower.radius,0,Math.PI*2); ctx.fill();
    ctx.fillStyle='#222'; ctx.strokeStyle='rgba(255,255,255,0.25)'; ctx.lineWidth=2; roundRect(ctx,-w/2,-h/2,w,h,6); ctx.fill(); ctx.stroke();
    ctx.fillStyle='#ff4d4d'; roundRect(ctx,-w*0.15,-h*0.42,w*0.55,h*0.35,6); ctx.fill();
    ctx.strokeStyle='#bbb'; ctx.lineWidth=3; ctx.beginPath(); ctx.moveTo(-w*0.4,-h*0.3); ctx.lineTo(-w*0.9,-h*0.9); ctx.moveTo(-w*0.25,-h*0.3); ctx.lineTo(-w*0.75,-h*0.9); ctx.stroke();
    ctx.restore();
  }
  function roundRect(ctx,x,y,w,h,r){ const rr=Math.min(r,w/2,h/2); ctx.beginPath(); ctx.moveTo(x+rr,y); ctx.arcTo(x+w,y,x+w,y+h,rr); ctx.arcTo(x+w,y+h,x,y+h,rr); ctx.arcTo(x,y+h,x,y,rr); ctx.arcTo(x,y,x+w,y,rr); ctx.closePath(); }

  // Input handling
  window.addEventListener('keydown', e=>{
    if (["ArrowUp","ArrowDown","ArrowLeft","ArrowRight"," "].includes(e.key)) e.preventDefault();
    const k=e.key.toLowerCase(); keys.add(k);
    if (k==='f') toggleFullscreen();
    if (k==='r') { state='intro'; hideWin(); hideFail(); showIntro(); hideBest(); try{ bgm.pause(); }catch(e){} }
    if (k==='m'){ musicEnabled=!musicEnabled; localStorage.setItem(MUSIC_KEY, musicEnabled?'true':'false'); setMusicUI(); if (!musicEnabled){ try{ bgm.pause(); }catch(e){} } else if(state==='playing'){ try{ bgm.play().catch(()=>{});}catch(e){} } }
    if (k==='enter' && state==='intro') startGame();
  }, { passive:false });
  window.addEventListener('keyup', e=>{ keys.delete(e.key.toLowerCase()); });

  // Music toggle
  musicToggle.addEventListener('click', ()=>{
    musicEnabled = !musicEnabled;
    localStorage.setItem(MUSIC_KEY, musicEnabled ? 'true' : 'false');
    setMusicUI();
    if (!musicEnabled){ try{ bgm.pause(); }catch(e){}; }
    else if (state==='playing'){ try{ bgm.play().catch(()=>{});}catch(e){} }
  });

  // Pointer: only capture when playing
  canvas.addEventListener('pointerdown', e=>{
    if (state !== 'playing') return;
    canvas.setPointerCapture(e.pointerId);
    pointerTarget=getPt(e);
  });
  canvas.addEventListener('pointermove', e=>{ if(pointerTarget) pointerTarget=getPt(e); });
  canvas.addEventListener('pointerup', e=>{ pointerTarget=null; });
  function getPt(e){ const rect=canvas.getBoundingClientRect(); return { x:e.clientX-rect.left, y:e.clientY-rect.top }; }

  // Virtual stick
  stick?.addEventListener('pointerdown', e=>{ stickActive=true; stick.setPointerCapture(e.pointerId); moveNub(e); });
  stick?.addEventListener('pointermove', e=>{ if(stickActive) moveNub(e); });
  stick?.addEventListener('pointerup', e=>{ stickActive=false; stickVec.x=stickVec.y=0; nub.style.left='50%'; nub.style.top='50%'; });
  function moveNub(e){ const r=60; const rect=stick.getBoundingClientRect(); const x=e.clientX-rect.left-r; const y=e.clientY-rect.top-r; const len=Math.hypot(x,y)||1; const max=40; const nx=(x/len)*Math.min(len,max); const ny=(y/len)*Math.min(len,max); nub.style.left=(r+nx)+'px'; nub.style.top=(r+ny)+'px'; stickVec.x=x/r; stickVec.y=y/r; }

  function toggleFullscreen(){ if(!document.fullscreenElement){ document.documentElement.requestFullscreen?.(); } else { document.exitFullscreen?.(); } }
  document.getElementById('fullscreen').addEventListener('click', toggleFullscreen);
  document.getElementById('reset').addEventListener('click', ()=>{ state='intro'; hideWin(); hideFail(); showIntro(); hideBest(); try{ bgm.pause(); }catch(e){} });

  window.addEventListener('resize', ()=>resize(true));

  // Best Times mobile toggle
  const sidebar = document.getElementById('sidebar');
  function hideBest(){ sidebar.classList.remove('show'); }
  function showBest(){ sidebar.classList.add('show'); }
  if (isTouch || window.innerWidth <= 768){ hideBest(); }
  bestToggle.addEventListener('click', ()=>{
    if (sidebar.classList.contains('show')) hideBest(); else showBest();
  });

  document.addEventListener('visibilitychange', ()=>{
    if (document.hidden){ try{ bgm.pause(); }catch(e){} }
    else if (state==='playing' && musicEnabled){ try{ bgm.play().catch(()=>{});}catch(e){} }
  });

  resize(true);

  // Intro & modal controls set with multiple events
  ['click','pointerdown','touchstart'].forEach(evt=>{
    startBtn.addEventListener(evt, (e)=>{ e.preventDefault(); e.stopPropagation(); startGame(); }, { passive:false });
    againBtn.addEventListener(evt, (e)=>{ e.preventDefault(); startGame(); }, { passive:false });
    retryBtn.addEventListener(evt, (e)=>{ e.preventDefault(); startGame(); }, { passive:false });
    if (closeModalBtn) closeModalBtn.addEventListener(evt, (e)=>{ e.preventDefault(); hideWin(); }, { passive:false });
    if (closeFailBtn) closeFailBtn.addEventListener(evt, (e)=>{ e.preventDefault(); hideFail(); }, { passive:false });
  });

  function startGame(){
    hideIntro(); hideWin(); hideFail();
    state='playing'; elapsed=0; tStart=performance.now(); initField();
    setTimeout(hideHelp, 4000);
    if (musicEnabled){ try { bgm.currentTime = 0; bgm.volume = 0.35; bgm.play().catch(()=>{}); } catch (e) {} }
  }
  function hideIntro(){ intro.style.display='none'; }
  function showIntro(){ intro.style.display='flex'; }
  function hideWin(){ winModal.classList.remove('show'); }
  function showWin(){ winModal.classList.add('show'); }
  function hideFail(){ failModal.classList.remove('show'); }
  function showFail(){ failModal.classList.add('show'); }

  function onAllCut(){
    if(state!=='playing') return;
    state='won';
    finalTimeEl.textContent=timeEl.textContent;
    saveBest(elapsed);
    renderBest();
    showWin();
  }

  function saveBest(ms){
    try{
      const arr=JSON.parse(localStorage.getItem(BEST_KEY)||'[]');
      arr.push(ms);
      arr.sort((a,b)=>a-b);
      localStorage.setItem(BEST_KEY, JSON.stringify(arr.slice(0,5)));
    }catch(e){}
  }
  function renderBest(){
    try{
      const arr=JSON.parse(localStorage.getItem(BEST_KEY)||'[]');
      bestListEl.innerHTML = arr.length? arr.map((ms,i)=>`<li><span>#${i+1}</span><span class='time'>${fmt(ms)}</span></li>`).join('') : '<li>No times yet</li>';
    }catch{
      bestListEl.innerHTML='<li>No times yet</li>';
    }
  }
  function fmt(ms){ const s=ms/1000; const m=Math.floor(s/60); const sec=Math.floor(s%60); const d=Math.floor((s-Math.floor(s))*10); return `${String(m).padStart(2,'0')}:${String(sec).padStart(2,'0')}.${d}`; }
  renderBest();

  // Main loop
  let last = performance.now();
  function loop(now){
    const dt = Math.min(0.033, (now-last)/1000); last = now;

    if (state==='playing'){
      elapsed = now - tStart;
      updateTime(elapsed);
      remainingMs -= (dt*1000);
      if (remainingMs <= 0){
        remainingMs = 0;
        if (cutCount < grassTotal){
          state = 'fail';
          finalPctEl.textContent = Math.round((cutCount/grassTotal)*100)+'%';
          showFail();
        }
      }
      cdEl.textContent = fmtCountdown(remainingMs);
    }

    // Input
    let ax=0, ay=0;
    if (keys.has('arrowup')||keys.has('w')) ay -= 1;
    if (keys.has('arrowdown')||keys.has('s')) ay += 1;
    if (keys.has('arrowleft')||keys.has('a')) ax -= 1;
    if (keys.has('arrowright')||keys.has('d')) ax += 1;
    if (Math.hypot(stickVec.x, stickVec.y) > 0.05){ ax = stickVec.x; ay = stickVec.y; }
    if (!ax && !ay && pointerTarget){ const dx=pointerTarget.x-mower.x; const dy=pointerTarget.y-mower.y; const L=Math.hypot(dx,dy); if(L>4){ ax=dx/L; ay=dy/L; }}

    const L = Math.hypot(ax,ay);
    if (L>0 && state!=='intro'){ mower.vx=(ax/L)*mower.speed; mower.vy=(ay/L)*mower.speed; }
    else { mower.vx*=0.9; mower.vy*=0.9; if(Math.hypot(mower.vx,mower.vy)<5){ mower.vx=mower.vy=0; } }

    const prevX=mower.x, prevY=mower.y;
    mower.x += mower.vx * dt; mower.y += mower.vy * dt;
    if (mower.x < 0) mower.x = 0; if (mower.x > W) mower.x = W;
    if (mower.y < SAFE_TOP) mower.y = SAFE_TOP; if (mower.y > H) mower.y = H;
    if (mower.x>house.x && mower.x<house.x+house.w && mower.y>house.y && mower.y<house.y+house.h){ mower.x=prevX; mower.y=prevY; }

    if (state!=='intro') cutUnderMower();

    // Draw
    drawField();
    drawFence();
    drawHouse();
    drawGuy();
    drawMower();

    if ((now|0)%8===0) updatePercent();
    requestAnimationFrame(loop);
  }
  requestAnimationFrame(loop);
})();
</script>
</body>
</html>
